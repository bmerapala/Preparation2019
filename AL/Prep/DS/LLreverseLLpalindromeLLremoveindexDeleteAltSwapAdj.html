<script>
SinglyList.prototype.remove = function(index){
  var current = this.head, count=0, previous;
  //if empty, exit out
  if(this._length===0) return;

  //Check against first node
  if(index===0){
      this.head = current.next;
      this._length--;
  }else{

      while(count<index-1){
        previous = current;
        current = current.next;
        count++;
      }//end while

      previous.next = current.next;
      this._length--;

      return this.head;
  }// end if

};

void pairWiseSwap()
    {
        Node temp = head;
 
        /* Traverse only till there are atleast 2 nodes left */
        while (temp != null && temp.next != null) {
 
            /* Swap the data */
            int k = temp.data;
            temp.data = temp.next.data;
            temp.next.data = k;
            temp = temp.next.next;
         }
    } 
	
	
 void deleteAlt()
    {
       if (head == null) 
          return;
 
       Node prev = head;
       Node now = head.next;
 
       while (prev != null && now != null) 
       {           
           /* Change next link of previus node */
           prev.next = now.next;
 
           /* Free node */
           now = null;
 
           /*Update prev and now */
           prev = prev.next;
           if (prev != null) 
              now = prev.next;
       }
    }   
	
	
	
	
function LinkedList () {
    this.head = null;
}

LinkedList.prototype.isPalindrome = function () {
  // Empty or a single element Linked List
  if (!this.head || !this.head.next) {
    console.log('No duplicates were found. Empty or a single element Linked List.');
    return;
  }

  // Create a deep copy of L1 so we can reverse it and compare with L1
  var temp = JSON.stringify(this); // Serialize L1, remember this can be an expensive operation
  var L2 = JSON.parse(temp); // Deserialize L1, remember this can be an expensive operation

  // Object.setPrototypeOf(L2, this); // Change L2's default prototype. This is ES6 Feature. OPTIONAL
  
  L2.reverseLinkedList(); 

  var l2 = L2.head;
  var l1 = this.head;
  
  while (l2) {
    if (l2.data !== l1.data) {
      return false;
    }
    l2 = l2.next;
    l1 = l1.next;
  }

  return true;
};

// Create an instance of a LinkedList class
var L1 = new LinkedList();

// Create a linked list with six elements
L1.insertNodeAtTail(5);
L1.insertNodeAtTail(6);
L1.insertNodeAtTail(7);
L1.insertNodeAtTail(8); 
// L1.insertNodeAtTail(6); 
L1.insertNodeAtTail(9); 
// L1.insertNodeAtTail(5);

console.log(L1.isPalindrome()); // false

// Comment L#36, L#38, L#44 and Uncomment L#37, L#39 to make list palindrome
// console.log(L1.isPalindrome()); // true


function reversesll(sll){
  
  if(!sll.head || !sll.head.next) return sll;

  var nodes=[], 
    current = sll.head;
  //storing all the nodes in an array
  while(current){
    nodes.push(current);
    current = current.next;
  }
    
  var reversedLL = new LinkedList();
  
  reversedLL.head = nodes.pop();
  current = reversedLL.head;
  
  var node = nodes.pop();  
  //make sure to make next of the newly inserted node to be null
  //other wise the last node of your SLL will retain its old next.
  while(node){
     node.next = null;
     current.next = node;
     
     current = current.next;
     node = nodes.pop();
  }
  return reversedLL;
}
</script>